ifndef::imagesdir[:imagesdir: ../images]

[[section-runtime-view]]
== Runtime View


[role="arc42help"]
****
.Contents
The runtime view describes concrete behavior and interactions of the systemâ€™s building blocks in form of scenarios from the following areas:

* important use cases or features: how do building blocks execute them?
* interactions at critical external interfaces: how do building blocks cooperate with users and neighboring systems?
* operation and administration: launch, start-up, stop
* error and exception scenarios

Remark: The main criterion for the choice of possible scenarios (sequences, workflows) is their *architectural relevance*. It is *not* important to describe a large number of scenarios. You should rather document a representative selection.

.Motivation
You should understand how (instances of) building blocks of your system perform their job and communicate at runtime.
You will mainly capture scenarios in your documentation to communicate your architecture to stakeholders that are less willing or able to read and understand the static models (building block view, deployment view).

.Form
There are many notations for describing scenarios, e.g.

* numbered list of steps (in natural language)
* activity diagrams or flow charts
* sequence diagrams
* BPMN or EPCs (event process chains)
* state machines
* ...


.Further Information

See https://docs.arc42.org/section-6/[Runtime View] in the arc42 documentation.

****

=== Login scenario

When the user wants to login into the application (WIQ), the user navigates to the login page. Then, the Frontend requests the login page to the backend. Once it is received, the Frontend displays it. The Frontend will show a form that allows the user to enter their details (username and password), which are then sent to the backend in order to be verified if they are correct or not. Then, the Backend asks the Database for the password given the username. The Database will return an encrypted password. The Backend will encrypt the password provided by the user and then compare it with the one from the database. If the passwords do not match, an error message showing "Incorrect credentials" will appear to the user and if they are correct, a success message "Login successful" confirms the login and the user finally will be able to access the application.

This case scenario is also represented on the following diagram:

[mermaid]
....
sequenceDiagram
    actor User as User
    
    User->>Frontend: Navigates to login page
    Frontend->>Backend: Requests login page
    Backend-->>Frontend: Sends login page
    Frontend-->>User: Displays login page
    User->>Frontend: Enters details (username, password)
    Frontend->>Backend: Sends user details
    Backend->>Database: Asks for encrypted password by username
    Database-->>Backend: Responds with the encrypted password of the user
    Backend-->Backend: Tests if passwords are equal after encryptation
    alt Credentials are incorrect
        Backend-->>Frontend: Sends error message "Incorrect credentials"
        Frontend-->>User: Displays error message "Incorrect credentials"
    else Credentials are correct
        Backend-->>Frontend: Sends success message "Login successful"
        Frontend-->>User: Displays success message "Login successful"
    end
....


=== Question Generation

When a user starts a game through the Frontend, it triggers a request for generating questions to the Backend. The Backend (Gateway) works with the QGS (Question Generator Service) to generate questions. For each question, first QGS requests a question template from the Database, which is then filled with relevant data from the WQS (Wikidata Query Service). After filling the template, QGS asks WQS for answers and distractors. Once all questions are generated, QGS sends them back to the Backend, so again the response then can be redirected towards the Frontend. Finally, the Frontend displays the questions of the game.

This case scenario is also represented on the following diagram:

[mermaid]
....
 sequenceDiagram
    actor U as User
    participant FE as Frontend 
    participant BE as Backend 
    participant QGS as Question Generation Service 
    participant WQS as Wikidata Query Service 
    participant DB as Database 

    U->>FE: Starts a Game
    FE->>BE: Requests Questions
    BE->>QGS: Generate Questions

    loop for each question
        QGS->>DB: Request Question Template
        DB-->>QGS: Return Question Template
        QGS->>WQS: Request Data
        WQS-->>QGS: Return Data
        QGS-->QGS: Fill Template
        QGS->>WQS: Request Answer + Distractors
        WQS-->>QGS: Return Answer + Distractors
        QGS-->QGS: Create Question
    end 
    QGS-->>BE: Return Questions
    BE-->>FE: Return Questions
    FE->>U: Display Questions
....

=== User statistics recording scenario

When a user answers a question, the Frontend determines if the answer was correct or not. Then, that data is sent to the Backend and then forwarded to the History Service, which is in charge of updating the Database with the updated user history. This process is repeated for each answer to a question.

This case scenario is also represented on the following diagram:

[mermaid]
....
 sequenceDiagram
    actor U as User
    participant FE as Frontend 
    participant BE as Backend 
    participant HS as History Service
    participant DB as Database 

    U->>FE: Answers a Question
    FE-->FE: Determines if the answer is correct
    FE->>BE: Indicates correctness of the answer
    BE->>HS: Save the user history
    HS->>DB: Updates the user history
....